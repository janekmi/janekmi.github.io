<!-- Creator     : groff version 1.18.1.4 -->
<!-- CreationDate: Mon Mar 21 14:06:24 2016 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>libpmem</title>
</head>
<body>

<h1 align=center>libpmem</h1>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#MOST COMMONLY USED FUNCTIONS">MOST COMMONLY USED FUNCTIONS</a><br>
<a href="#PARTIAL FLUSHING OPERATIONS">PARTIAL FLUSHING OPERATIONS</a><br>
<a href="#COPYING TO PERSISTENT MEMORY">COPYING TO PERSISTENT MEMORY</a><br>
<a href="#LIBRARY API VERSIONING">LIBRARY API VERSIONING</a><br>
<a href="#DEBUGGING AND ERROR HANDLING">DEBUGGING AND ERROR HANDLING</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>
<a name="NAME"></a>
<h2>NAME</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>libpmem &minus; persistent memory support library</p>
</td>
</table>
<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<pre><b>#include &lt;libpmem.h&gt;

cc ... -lpmem

Most commonly used functions:

int pmem_is_pmem(const void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>);
void pmem_persist(const void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>);
int pmem_msync(const void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>);
void *pmem_map_file(const char *</b><i>path</i><b>, size_t</b> <i>len</i><b>, int</b> <i>flags</i><b>,
    mode_t</b> <i>mode</i><b>, size_t *</b><i>mapped_lenp</i><b>, int *</b><i>is_pmemp</i><b>);
int pmem_unmap(void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>);

Partial flushing operations:

void pmem_flush(const void *</b><i>addr</i><b>, size_t</b> <i>len</i><b>);
void pmem_drain(void);
int pmem_has_hw_drain(void);

Copying to persistent memory:

void *pmem_memmove_persist(void *</b><i>pmemdest</i><b>, const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
void *pmem_memcpy_persist(void *</b><i>pmemdest</i><b>, const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
void *pmem_memset_persist(void *</b><i>pmemdest</i><b>, int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);
void *pmem_memmove_nodrain(void *</b><i>pmemdest</i><b>, const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
void *pmem_memcpy_nodrain(void *</b><i>pmemdest</i><b>, const void *</b><i>src</i><b>, size_t</b> <i>len</i><b>);
void *pmem_memset_nodrain(void *</b><i>pmemdest</i><b>, int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);

Library API versioning:

const char *pmem_check_version(
    unsigned</b> <i>major_required</i><b>,
    unsigned</b> <i>minor_required</i><b>);
</b></pre>
<!-- INDENTATION -->
<p><b>Error handling:</b></p>
<!-- INDENTATION -->
<p><b>const char *pmem_errormsg(void);</b></p>
</td>
</table>
<a name="DESCRIPTION"></a>
<h2>DESCRIPTION</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>libpmem</b> provides low-level <i>persistent
memory</i> (pmem) support for applications using direct
access storage (DAX), which is storage that supports
load/store access without paging blocks from a block storage
device. Some types of <i>non-volatile memory DIMMs</i>
(NVDIMMs) provide this type of byte addressable access to
storage. A <i>persistent memory aware file system</i> is
typically used to expose the direct access to applications.
Memory mapping a file from this type of file system results
in the load/store, non-paged access to pmem.</p>
<!-- INDENTATION -->
<p>This library is for applications that use persistent
memory directly, without the help of any library-supplied
transactions or memory allocation. Higher-level libraries
that build on <b>libpmem</b> are available and are
recommended for most applications, see:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>libpmemobj</b>(3), a general use persistent memory
API, providing memory allocation and transactional
operations on variable-sized objects.</p>
<!-- INDENTATION -->
<p><b>libpmemblk</b>(3), providing pmem-resident arrays of
fixed-sized blocks with atomic updates.</p>
<!-- INDENTATION -->
<p><b>libpmemlog</b>(3), providing a pmem-resident log
file.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Under normal usage, <b>libpmem</b> will never print
messages or intentionally cause the process to exit. The
only exception to this is the debugging information, when
enabled, as described under <b>DEBUGGING AND ERROR
HANDLING</b> below.</p>
</td>
</table>
<a name="MOST COMMONLY USED FUNCTIONS"></a>
<h2>MOST COMMONLY USED FUNCTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Most pmem-aware applications will take advantage of
higher level libraries that alleviate the application from
calling into <b>libpmem</b> directly. Application developers
that wish to access raw memory mapped persistence directly
(via <b>mmap</b>(2)) and that wish to take on the
responsibility for flushing stores to persistence will find
the functions described in this section to be the most
commonly used.</p>
<!-- INDENTATION -->
<p><b>int pmem_is_pmem(const void *</b><i>addr</i><b>,
size_t</b> <i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmem_is_pmem</b>() function returns true only if
the entire range [<i>addr</i>, <i>addr</i>+<i>len</i>)
consists of persistent memory. A true return from
<b>pmem_is_pmem</b>() means it is safe to use
<b>pmem_persist</b>() and the related functions below to
make changes durable for that memory range.</p>
<!-- INDENTATION -->
<p>The implementation of <b>pmem_is_pmem</b>() requires a
non-trivial amount of work to determine if the given range
is entirely persistent memory. For this reason, it is better
to call <b>pmem_is_pmem</b>() once when a range of memory is
first encountered, save the result, and use the saved result
to determine whether <b>pmem_persist</b>() or
<b>msync</b>(2) is appropriate for flushing changes to
persistence. Calling <b>pmem_is_pmem</b>() each time changes
are flushed to persistence will not perform well.</p>
<!-- INDENTATION -->
<p>WARNING: Using <b>pmem_persist</b>() on a range where
<b>pmem_is_pmem</b>() returns false may not do anything
useful -- use <b>msync</b>(2) instead.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void pmem_persist(const void *</b><i>addr</i><b>,
size_t</b> <i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>Force any changes in the range [<i>addr</i>,
<i>addr</i>+<i>len</i>) to be stored durably in persistent
memory. This is equivalent to calling <b>msync</b>(2) but
may be more optimal and will avoid calling into the kernel
if possible. There are no alignment restrictions on the
range described by <i>addr</i> and <i>len</i>, but
<b>pmem_persist</b>() may expand the range as necessary to
meet platform alignment requirements.</p>
<!-- INDENTATION -->
<p>WARNING: Like <b>msync</b>(2), there is nothing atomic or
transactional about this call. Any unwritten stores in the
given range will be written, but some stores may have
already been written by virtue of normal cache
eviction/replacement policies. Correctly written code must
not depend on stores waiting until <b>pmem_persist</b>() is
called to become persistent -- they can become persistent at
any time before <b>pmem_persist</b>() is called.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmem_msync(const void *</b><i>addr</i><b>,
size_t</b> <i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The function <b>pmem_msync</b>() is like
<b>pmem_persist</b>() in that it forces any changes in the
range [<i>addr</i>, <i>addr</i>+<i>len</i>) to be stored
durably. Since it calls <b>msync</b>(), this function works
on either persistent memory or a memory mapped file on
traditional storage. <b>pmem_msync</b>() takes steps to
ensure the alignment of addresses and lengths passed to
<b>msync</b>() meet the requirements of that system call. It
calls <b>msync</b>() with the <i>MS_SYNC</i> flag as
described in <b>msync</b>(2). Typically the application only
checks for the existence of persistent memory once, and then
uses that result throughout the program, for example:</p>
<!-- INDENTATION -->
<pre>    /* do this call once, after the pmem is memory mapped */
    int is_pmem = pmem_is_pmem(rangeaddr, rangelen);

   /* ... make changes to a range of pmem ... */

   /* make the changes durable */
    if (is_pmem)
        pmem_persist(subrangeaddr, subrangelen);
    else
        pmem_msync(subrangeaddr, subrangelen);

   /* ... */
</pre>
<!-- INDENTATION -->
<p>The return value of <b>pmem_msync</b>() is the return
value of <b>msync</b>(), which can return -1 and set errno
to indicate an error.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void *pmem_map_file(const char *</b><i>path</i><b>,
size_t</b> <i>len</i><b>, int</b> <i>flags</i><b>,<br>
mode_t</b> <i>mode</i><b>, size_t
*</b><i>mapped_lenp</i><b>, int
*</b><i>is_pmemp</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>Given a <i>path</i>, <b>pmem_map_file</b>() function
creates a new read/write mapping for the named file. It will
map the file using <b>mmap</b>(2), but it also takes extra
steps to make large page mappings more likely.</p>
<!-- INDENTATION -->
<p>On success, <b>pmem_map_file</b>() returns a pointer to
mapped area. If <i>mapped_lenp</i> is not NULL, the length
of the mapping is also stored at the address it points to.
The <i>is_pmemp</i> argument, if non-NULL, points to a flag
that <b>pmem_is_pmem</b>() sets to say if the mapped file is
actual pmem, or if <b>msync</b>() must be used to flush
writes for the mapped range. On error, NULL is returned,
errno is set appropriately, and <i>mapped_lenp</i> and
<i>is_pmemp</i> are left untouched.</p>
<!-- INDENTATION -->
<p>The <i>flags</i> argument can be 0 or bitwise OR of one
or more of the following file creation flags:</p>
<!-- INDENTATION -->
<p><b>PMEM_FILE_CREATE</b> - Create the named file if it
does not exist. <i>len</i> must be non-zero and specifies
the size of the file to be created. <i>mode</i> has the same
meaning as for <b>open</b>(2) and specifies the mode to use
in case a new file is created. If neither
<b>PMEM_FILE_CREATE</b> nor <b>PMEM_FILE_TMPFILE</b> is
specified, then <i>mode</i> is ignored.</p>
<!-- INDENTATION -->
<p><b>PMEM_FILE_EXCL</b> - Same meaning as <b>O_EXCL</b> on
<b>open</b>(2) - Ensure that this call creates the file. If
this flag is specified in conjunction with
<b>PMEM_FILE_CREATE</b>, and pathname already exists, then
<b>pmem_map_file</b>() will fail.</p>
<!-- INDENTATION -->
<p><b>PMEM_FILE_TMPFILE</b> - Same meaning as
<b>O_TMPFILE</b> on <b>open</b>(2). Create a mapping for an
unnamed temporary file. <b>PMEM_FILE_CREATE</b> and
<i>len</i> must be specified and <i>path</i> must be an
existing directory name.</p>
<!-- INDENTATION -->
<p><b>PMEM_FILE_SPARSE</b> - When creating a file, create a
sparse (holey) file instead of calling
<b>posix_fallocate</b>(2). Valid only if specified in
conjunction with <b>PMEM_FILE_CREATE</b> or
<b>PMEM_FILE_TMPFILE</b>, otherwise ignored.</p>
<!-- INDENTATION -->
<p>If creation flags are not supplied, then
<b>pmem_map_file</b>() creates a mapping for an existing
file. In such case, <i>len</i> should be zero. The entire
file is mapped to memory; its length is used as the length
of the mapping and returned via <i>mapped_lenp</i>.</p>
<!-- INDENTATION -->
<p>To delete mappings created with <b>pmem_map_file</b>(),
use <b>pmem_unmap</b>().</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmem_unmap(void *</b><i>addr</i><b>, size_t</b>
<i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmem_unmap</b>() function deletes all the mappings
for the specified address range, and causes further
references to addresses within the range to generate invalid
memory references. It will use the address specified by the
parameter <i>addr</i>, where <i>addr</i> must be a
previously mapped region. <b>pmem_unmap</b>() will delete
the mappings using the <b>munmap</b>(2), On success,
<b>pmem_unmap</b>() returns zero. On error, -1 is returned,
and errno is set appropriately.</p>
</td>
</table>
<a name="PARTIAL FLUSHING OPERATIONS"></a>
<h2>PARTIAL FLUSHING OPERATIONS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The functions in this section provide access to the
stages of flushing to persistence, for the less common cases
where an application needs more control of the flushing
operations than the <b>pmem_persist</b>() function described
above.</p>
<!-- INDENTATION -->
<p><b>void pmem_flush(const void *</b><i>addr</i><b>,
size_t</b> <i>len</i><b>);<br>
void pmem_drain(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>These functions provide partial versions of the
<b>pmem_persist</b>() function described above.
<b>pmem_persist</b>() can be thought of as this:</p>
<!-- INDENTATION -->
<pre>void
pmem_persist(const void *addr, size_t len)
{
    /* flush the processor caches */
    pmem_flush(addr, len);

    /* wait for any pmem stores to drain from HW buffers */
    pmem_drain();
}
</pre>
<!-- INDENTATION -->
<p>These functions allow advanced programs to create their
own variations of <b>pmem_persist</b>(). For example, a
program that needs to flush several discontiguous ranges can
call <b>pmem_flush</b>() for each range and then follow up
by calling <b>pmem_drain</b>() once.</p>
<!-- INDENTATION -->
<p>NOTE: Some software is designed for custom platforms that
obviate the need for using PCOMMIT (perhaps the platform
issues PCOMMIT on shutdown or something similar). Even in
such cases, it is recommended that applications using
<b>libpmem</b> do not skip the step of calling
<b>pmem_drain</b>(), either directly or by using
<b>pmem_persist</b>(). The recommended way to inhibit use of
the PCOMMIT instruction is by setting the
<b>PMEM_NO_PCOMMIT</b> environment variable as described in
the <b>ENVIRONMENT VARIABLES</b> section.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int pmem_has_hw_drain(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmem_has_hw_drain</b>() function returns true if
the machine supports the <i>hardware drain</i> function for
persistent memory, such as that provided by the
<b>PCOMMIT</b> instruction on Intel processors. If support
for hardware drain is not found, or cannot be detected by
the library, <b>pmem_has_hw_drain</b>() will return false.
Although it is typically an administrative task to provide
the correct platform configuration for persistent memory,
this function is provided for the less common cases where an
application needs to ensure this feature is available. Note
that the lack of this feature means that calling
<b>pmem_persist</b>() may not fully ensure stores are
durable, without additional platform features such as
Asynchronous DRAM Refresh (ADR) or something similar.</p>
</td>
</table>
<a name="COPYING TO PERSISTENT MEMORY"></a>
<h2>COPYING TO PERSISTENT MEMORY</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The functions in this section provide optimized copying
to persistent memory.</p>
<!-- INDENTATION -->
<p><b>void *pmem_memmove_persist(void
*</b><i>pmemdest</i><b>, const void *</b><i>src</i><b>,<br>
size_t</b> <i>len</i><b>);<br>
void *pmem_memcpy_persist(void *</b><i>pmemdest</i><b>,
const void *</b><i>src</i><b>, size_t</b>
<i>len</i><b>);<br>
void *pmem_memset_persist(void *</b><i>pmemdest</i><b>,
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmem_memmove_persist</b>(),
<b>pmem_memcpy_persist</b>(), and
<b>pmem_memset_persist</b>(), functions provide the same
memory copying as their namesakes <b>memmove</b>(3)
<b>memcpy</b>(3), and <b>memset</b>(3), and ensure that the
result has been flushed to persistence before returning. For
example, the following code is functionally equivalent to
<b>pmem_memmove_persist</b>():</p>
<!-- INDENTATION -->
<pre>void *
pmem_memmove_persist(void *pmemdest, const void *src, size_t len)
{
    void *retval = memmove(pmemdest, src, len);

   pmem_persist(pmemdest, len);

   return retval;
}
</pre>
<!-- INDENTATION -->
<p>Calling <b>pmem_memmove_persist</b>() may out-perform the
above code, however, since the <b>libpmem</b> implementation
may take advantage of the fact that <i>pmemdest</i> is
persistent memory and use instructions such as
<i>non-temporal</i> stores to avoid the need to flush
processor caches.</p>
<!-- INDENTATION -->
<p>WARNING: Using these functions where
<b>pmem_is_pmem</b>() returns false may not do anything
useful. Use the normal libc functions in that case.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>void *pmem_memmove_nodrain(void
*</b><i>pmemdest</i><b>, const void *</b><i>src</i><b>,<br>
size_t</b> <i>len</i><b>);<br>
void *pmem_memcpy_nodrain(void *</b><i>pmemdest</i><b>,
const void *</b><i>src</i><b>, size_t</b>
<i>len</i><b>);<br>
void *pmem_memset_nodrain(void *</b><i>pmemdest</i><b>,
int</b> <i>c</i><b>, size_t</b> <i>len</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmem_memmove_nodrain</b>(),
<b>pmem_memcpy_nodrain</b>() and
<b>pmem_memset_nodrain</b>() functions are similar to
<b>pmem_memmove_persist</b>(), <b>pmem_memcpy_persist</b>(),
and <b>pmem_memset_persist</b>() described above, except
they skip the final <b>pmem_drain</b>() step. This allows
applications to optimize cases where several ranges are
being copied to persistent memory, followed by a single call
to <b>pmem_drain</b>(). The following example illustrates
how these functions might be used to avoid multiple calls to
<b>pmem_drain</b>() when copying several ranges of memory to
pmem:</p>
<!-- INDENTATION -->
<pre>    /* ... write several ranges to pmem ... */
    pmem_memcpy_nodrain(pmemdest1, src1, len1);
    pmem_memcpy_nodrain(pmemdest2, src2, len2);

   /* ... */

   /* wait for any pmem stores to drain from HW buffers */
    pmem_drain();
</pre>
<!-- INDENTATION -->
<p>WARNING: Using <b>pmem_memmove_nodrain</b>(),
<b>pmem_memcpy_nodrain</b>() or <b>pmem_memset_nodrain</b>()
on a destination where <b>pmem_is_pmem</b>() returns false
may not do anything useful.</p>
</td>
</table>
<a name="LIBRARY API VERSIONING"></a>
<h2>LIBRARY API VERSIONING</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This section describes how the library API is versioned,
allowing applications to work with an evolving API.</p>
<!-- INDENTATION -->
<p><b>const char *pmem_check_version(<br>
unsigned</b> <i>major_required</i><b>,<br>
unsigned</b> <i>minor_required</i><b>);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmem_check_version</b>() function is used to see
if the installed <b>libpmem</b> supports the version of the
library API required by an application. The easiest way to
do this is for the application to supply the compile-time
version information, supplied by defines in
<b>&lt;libpmem.h&gt;</b>, like this:</p>
<!-- INDENTATION -->
<pre>reason = pmem_check_version(PMEM_MAJOR_VERSION,
                            PMEM_MINOR_VERSION);
if (reason != NULL) {
    /*  version check failed, reason string tells you why */
}
</pre>
<!-- INDENTATION -->
<p>Any mismatch in the major version number is considered a
failure, but a library with a newer minor version number
will pass this check since increasing minor versions imply
backwards compatibility.</p>
<!-- INDENTATION -->
<p>An application can also check specifically for the
existence of an interface by checking for the version where
that interface was introduced. These versions are documented
in this man page as follows: unless otherwise specified, all
interfaces described here are available in version 1.0 of
the library. Interfaces added after version 1.0 will contain
the text <i>introduced in version x.y</i> in the section of
this manual describing the feature.</p>
<!-- INDENTATION -->
<p>When the version check performed by
<b>pmem_check_version</b>() is successful, the return value
is NULL. Otherwise the return value is a static string
describing the reason for failing the version check. The
string returned by <b>pmem_check_version</b>() must not be
modified or freed.</p>
</td>
</table>
<a name="DEBUGGING AND ERROR HANDLING"></a>
<h2>DEBUGGING AND ERROR HANDLING</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Two versions of <b>libpmem</b> are typically available on
a development system. The normal version, accessed when a
program is linked using the <b>-lpmem</b> option, is
optimized for performance. That version skips checks that
impact performance and never logs any trace information or
performs any run-time assertions. If an error is detected
during the call to <b>libpmem</b> function, an application
may retrieve an error message describing the reason of
failure using the following function:</p>
<!-- INDENTATION -->
<p><b>const char *pmem_errormsg(void);</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>The <b>pmem_errormsg</b>() function returns a pointer to
a static buffer containing the last error message logged for
current thread. The error message may include description of
the corresponding error code (if errno was set), as returned
by <b>strerror</b>(3). The error message buffer is
thread-local; errors encountered in one thread do not affect
its value in other threads. The buffer is never cleared by
any library function; its content is significant only when
the return value of the immediately preceding call to
<b>libpmem</b> function indicated an error, or if errno was
set. The application must not modify or free the error
message string, but it may be modified by subsequent calls
to other library functions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>A second version of <b>libpmem</b>, accessed when a
program uses the libraries under <b>/usr/lib/nvml_debug</b>,
contains run-time assertions and trace points. The typical
way to access the debug version is to set the environment
variable <b>LD_LIBRARY_PATH</b> to
<b>/usr/lib/nvml_debug</b> or <b>/usr/lib64/nvml_debug</b>
depending on where the debug libraries are installed on the
system. The trace points in the debug version of the library
are enabled using the environment variable
<b>PMEM_LOG_LEVEL</b>, which can be set to the following
values:</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>0</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>This is the default level when <b>PMEM_LOG_LEVEL</b> is
not set. No log messages are emitted at this level.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>1</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>Additional details on any errors detected are logged (in
addition to returning the errno-based errors as usual). The
same information may be retrieved using
<b>pmem_errormsg</b>().</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>2</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>A trace of basic operations is logged.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>3</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>This level enables a very verbose amount of function
call tracing in the library.</p>
</td>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="2%">

<p>4</p>
</td>
<td width="7%"></td>
<td width="77%">

<p>This level enables voluminous and fairly obscure tracing
information that is likely only useful to the <b>libpmem</b>
developers.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The environment variable <b>PMEM_LOG_FILE</b> specifies a
file name where all logging information should be written.
If the last character in the name is &quot;-&quot;, the PID
of the current process will be appended to the file name
when the log file is created. If <b>PMEM_LOG_FILE</b> is not
set, the logging output goes to stderr.</p>
<!-- INDENTATION -->
<p>Setting the environment variable <b>PMEM_LOG_LEVEL</b>
has no effect on the non-debug version of
<b>libpmem</b>.</p>
</td>
</table>
<a name="ENVIRONMENT VARIABLES"></a>
<h2>ENVIRONMENT VARIABLES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>libpmem</b> can change its default behavior based on
the following environment variables. These are largely
intended for testing and are not normally required.</p>
<!-- INDENTATION -->
<p><b>PMEM_IS_PMEM_FORCE=</b><i>val</i></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>If <i>val</i> is 0 (zero), then <b>pmem_is_pmem</b>()
will always return false. Setting <i>val</i> to 1 causes
<b>pmem_is_pmem</b>() to always return true. This variable
is mostly used for testing but can be used to force pmem
behavior on a system where a range of pmem is not detectable
as pmem for some reason.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEM_NO_PCOMMIT=1</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>Setting this environment variable to 1 forces
<b>libpmem</b> to never issue the Intel PCOMMIT instruction.
This can be used on platforms where the hardware drain
function is performed some other way, like automatic
flushing during a power failure.</p>
<!-- INDENTATION -->
<p>WARNING: Using this environment variable incorrectly may
impact program correctness.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEM_NO_CLWB=1</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>Setting this environment variable to 1 forces
<b>libpmem</b> to never issue the <b>CLWB</b> instruction on
Intel hardware, falling back to other cache flush
instructions instead (<b>CLFLUSHOPT</b> or <b>CLFLUSH</b> on
Intel hardware). Without this environment variable,
<b>libpmem</b> will always use the <b>CLWB</b> instruction
for flushing processor caches on platforms that support the
instruction. This variable is intended for use during
library testing but may be required for some rare cases
where using <b>CLWB</b> has a negative impact on
performance.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEM_NO_CLFLUSHOPT=1</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>Setting this environment variable to 1 forces
<b>libpmem</b> to never issue the <b>CLFLUSHOPT</b>
instruction on Intel hardware, falling back to the
<b>CLFLUSH</b> instructions instead. Without this
environment variable, <b>libpmem</b> will always use the
<b>CLFLUSHOPT</b> instruction for flushing processor caches
on platforms that support the instruction, but where
<b>CLWB</b> is not available. This variable is intended for
use during library testing.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEM_NO_MOVNT=1</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>Setting this environment variable to 1 forces
<b>libpmem</b> to never use the <i>non-temporal</i> move
instructions on Intel hardware. Without this environment
variable, <b>libpmem</b> will use the non-temporal
instructions for copying larger ranges to persistent memory
on platforms that support the instructions. This variable is
intended for use during library testing.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEM_MOVNT_THRESHOLD=</b><i>val</i></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>This environment variable allows overriding the minimal
length of <b>pmem_memcpy_*</b>(), <b>pmem_memmove_*</b>() or
<b>pmem_memset_*</b>() operations, for which <b>libpmem</b>
uses <i>non-temporal</i> move instructions. Setting this
environment variable to 0 forces <b>libpmem</b> to always
use the <i>non-temporal</i> move instructions if available.
It has no effect if <b>PMEM_NO_MOVNT</b> variable is set to
1. This variable is intended for use during library
testing.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>PMEM_MMAP_HINT=</b><i>val</i> This environment
variable allows overriding the hint address used by
<b>pmem_map_file</b>(). If set, it also disables mapping
address randomization. This variable is intended for use
during library testing and debugging. Setting it to some
fairly large value (i.e. 0x10000000000) will very likely
result in mapping the file at the specified address (if not
used) or at the first unused region above given address,
without adding any random offset. When debugging, this makes
it easier to calculate the actual address of the persistent
memory block, based on its offset in the file. In case of
<b>libpmemobj</b> it simplifies conversion of a persistent
object identifier (OID) into a direct pointer to the object.
<b>NOTE: Setting this environment variable affects all the
NVM libraries,</b> disabling mapping address randomization
and causing the specified address to be used as a hint about
where to place the mapping.</p>
</td>
</table>
<a name="EXAMPLES"></a>
<h2>EXAMPLES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The following example uses <b>libpmem</b> to flush
changes made to raw, memory-mapped persistent memory.</p>
<!-- INDENTATION -->
<p>WARNING: there is nothing transactional about the
<b>pmem_persist</b>() or <b>pmem_msync</b>() calls in this
example. Interrupting the program may result in a partial
write to pmem. Use a transactional library such as
<b>libpmemobj</b>(3) to avoid torn updates.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<pre>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;libpmem.h&gt;

/* using 4k of pmem for this example */
</pre>
</td>
</table>
<!-- TABS -->

<table width="100%" border=0 rules="none" frame="void"
       cols="5" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>#define</p>
</td>
<td width="7%"></td>
<td width="7%">

<p>PMEM_LEN 4096</p>
</td>
<td width="57%">
</td>
<tr valign="top" align="left">
<td width="20%"></td>
<td width="7%">

<p>#define</p>
</td>
<td width="7%"></td>
<td width="7%">

<p>PATH &quot;/pmem-fs/myfile&quot;</p>
</td>
<td width="57%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>int<br>
main(int argc, char *argv[])<br>
{</p></td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="7" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>char *pmemaddr;</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>size_t mapped_len;</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>int is_pmem;</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>/* create a pmem file and memory map it */</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>if ((pmemaddr = pmem_map_file(PATH, PMEM_LEN,
PMEM_FILE_CREATE,</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">
</td>
<td width="7%">
</td>
<td width="7%">
</td>
<td width="7%">

<p>0666, &amp;mapped_len, &amp;is_pmem)) == NULL) {</p>
</td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">
</td>
<td width="7%">

<p>perror(&quot;pmem_map_file&quot;);</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">
</td>
<td width="7%">

<p>exit(1);</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>}</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>/* store a string to the persistent memory */</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>strcpy(pmemaddr, &quot;hello, persistent
memory&quot;);</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>/* flush above strcpy to persistence */</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>if (is_pmem)</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">
</td>
<td width="7%">

<p>pmem_persist(pmemaddr, mapped_len);</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>else</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">
</td>
<td width="7%">

<p>pmem_msync(pmemaddr, mapped_len);</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>/*</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>* Delete the mappings. The region is also</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>* automatically unmapped when the process is</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>* terminated.</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>*/</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
<tr valign="top" align="left">
<td width="27%"></td>
<td width="0%"></td>
<td width="7%">

<p>pmem_unmap(pmemaddr, mapped_len);</p>
</td>
<td width="7%"></td>
<td width="7%"></td>
<td width="7%"></td>
<td width="42%">
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>}</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>See http://pmem.io/nvml/libpmem for more examples using
the <b>libpmem</b> API.</p>
</td>
</table>
<a name="ACKNOWLEDGEMENTS"></a>
<h2>ACKNOWLEDGEMENTS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>libpmem</b> builds on the persistent memory
programming model recommended by the SNIA NVM Programming
Technical Work Group:</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p>http://snia.org/nvmp</p>
</td>
</table>
<a name="SEE ALSO"></a>
<h2>SEE ALSO</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>open</b>(2), <b>mmap</b>(2), <b>munmap</b>(2),
<b>msync</b>(2), <b>strerror</b>(3), <b>libpmemobj</b>(3),
<b>libpmemblk</b>(3), <b>libpmemlog</b>(3),
<b>libvmem</b>(3) and <b>http://pmem.io</b>.</p>
</td>
</table>
<hr>
</body>
</html>
